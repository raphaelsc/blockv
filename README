blockv project is composed of blockv server and blockv FUSE (client).
blockv server is used to export a block device that can be accessed by blockv FUSE.

A blockv FUSE mount point may store a large number of files that link to different blockv servers.

This project is based on the concept of network block device. For further information:
https://en.wikipedia.org/wiki/Network_block_device

Getting started
-----

- Compile project with:
    g++ --std=c++14 `pkg-config fuse --cflags --libs` blockv_fuse.cc -o blockv_fuse;
    g++ --std=c++14 blockv_server.cc -o blockv_server;

    NOTE: There is no makefile because I am lazy, but I will try to add one as soon as possible.
    NOTE: Depends on FUSE.


Playing with network-based block device
-----

- Server side:
    1) Create a pseudo block device that will be accessed via network:
    qemu-img create -f raw -o size=500M ./pseudo_block_device.raw;

    2) Format pseudo block device with a file system and add to it any files you want to share:
    mkfs.ext2 ./pseudo_block_device;
    mkdir ./mount_point;
    sudo mount -t ext2 ./pseudo_block_device.raw ./mount_point;
    # At this point, add any files you want to share at ./mount_point.
    sudo umount ./mount_point;

    3) Run blockv server with pseudo block device:
    ./blockv_server ./pseudo_block_device.raw;

    NOTE: After server starts, clients can now read and write content of ./pseudo_block_device.raw;
          In the future, ./blockv_server will provide a read-only flag to forbid writes.
    NOTE: Server is still very naive, it doesn't even support multi-client yet.
    WARNING: for security reasons, we don't allow real block devices to be used with blockv server.

- Client side:
    1) Mount blockv:
    mkdir ./blockv_mount_point;
    ./blockv_fuse -d ./blockv_mount_point -o allow_root;

    NOTE: allow_root option requires adding 'user_allow_other' to /etc/fuse.conf

    2) Create a network-based block device that points to the server above:
    ln -s localhost:22222 ./blockv_mount_point/remote_block_device;

    NOTE: replace localhost by server ip.

    3) Mount the network-based block device:
    mkdir ./mount_point_for_remote_file_system;
    sudo mount -t ext2 -o loop ./blockv_mount_point/virtual_block_device ./mount_point_for_remote_file_system;

    At this point, you can fully use the file system stored in the remote block device.

    NOTE: Writes aren't supported yet. Support to write will be added soon.
    NOTE: blockv server may decide to allow only reads, so client wouldn't be able to write to remote file system.


Playing with memory-based block device
-----

1) Mount blockv:
    mkdir ./blockv_mount_point;
    ./blockv_fuse -d ./blockv_mount_point -o allow_root;

    NOTE: allow_root option requires adding 'user_allow_other' to /etc/fuse.conf

2) Create a memory-based block device of 30MB:
    truncate -s 30M ./blockv_mount_point/virtual_block_device;

3) Format the memory-based block device with ext2 file system:
    mkfs.ext2 ./blockv_mount_point/virtual_block_device;

    NOTE: ext2 filesystem was chosen arbitrarily. Any other file system supported by Linux should work as fine.

4) Mount the ext2 filesystem with:
    mkdir ./mount_point2;
    sudo mount -t ext2 -o loop ./blockv_mount_point/virtual_block_device ./mount_point2;

    At this point, you can fully use the file system stored in the memory-based block device.

    NOTE: ./mount_point2 is now home for a ext2 filesystem backed by memory RAM.
